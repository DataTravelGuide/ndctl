// SPDX-License-Identifier: LGPL-2.0

libcxl(3)
=========

NAME
----
libcxl - A library to interact with CXL devices through sysfs(5)
and ioctl(2) interfaces

SYNOPSIS
--------
[verse]
#include <cxl/libcxl.h>
cc ... -lcxl

DESCRIPTION
-----------
libcxl provides interfaces to interact with CXL devices in Linux, using sysfs
interfaces for most kernel interactions, and the ioctl() interface for command
submission.

The starting point for all library interfaces is a 'cxl_ctx' object,
returned by linklibcxl:cxl_new[3]. CXL 'Type 3' memory devices and other
CXL device objects are descendants of the cxl_ctx object, and can be
iterated via an object an iterator API of the form
cxl_<object>_foreach(<parent object>, <object iterator>).

MEMDEVS
-------
The object representing a CXL memory expander (Type 3 device) is 'struct
cxl_memdev'. Library interfaces related to these devices have the prefix
'cxl_memdev_'. These interfaces are mostly associated with sysfs
interactions (unless otherwise noted in their respective documentation
sections). They are typically used to retrieve data published by the
kernel, or to send data or trigger kernel operations for a given device.

=== MEMDEV: Enumeration
----
struct cxl_memdev *cxl_memdev_get_first(struct cxl_ctx *ctx);
struct cxl_memdev *cxl_memdev_get_next(struct cxl_memdev *memdev);
struct cxl_ctx *cxl_memdev_get_ctx(struct cxl_memdev *memdev);
const char *cxl_memdev_get_host(struct cxl_memdev *memdev)
struct cxl_memdev *cxl_endpoint_get_memdev(struct cxl_endpoint *endpoint);

#define cxl_memdev_foreach(ctx, memdev) \
        for (memdev = cxl_memdev_get_first(ctx); \
             memdev != NULL; \
             memdev = cxl_memdev_get_next(memdev))

----

CXL memdev instances are enumerated from the global library context
'struct cxl_ctx'. By default a memdev only offers a portal to submit
memory device commands, see the port, decoder, and endpoint APIs to
determine what if any CXL Memory Resources are reachable given a
specific memdev.

The host of a memdev is the PCIe Endpoint device that registered its CXL
capabilities with the Linux CXL core.

=== MEMDEV: Attributes
----
int cxl_memdev_get_id(struct cxl_memdev *memdev);
unsigned long long cxl_memdev_get_serial(struct cxl_memdev *memdev);
const char *cxl_memdev_get_devname(struct cxl_memdev *memdev);
int cxl_memdev_get_major(struct cxl_memdev *memdev);
int cxl_memdev_get_minor(struct cxl_memdev *memdev);
unsigned long long cxl_memdev_get_pmem_size(struct cxl_memdev *memdev);
unsigned long long cxl_memdev_get_ram_size(struct cxl_memdev *memdev);
const char *cxl_memdev_get_firmware_verison(struct cxl_memdev *memdev);
size_t cxl_memdev_get_label_size(struct cxl_memdev *memdev);
int cxl_memdev_nvdimm_bridge_active(struct cxl_memdev *memdev);
----

A memdev is given a kernel device name of the form "mem%d" where an id
(cxl_memdev_get_id()) is dynamically allocated as devices are
discovered. Note that there are no guarantees that ids / kernel device
names for memdevs are stable from one boot to the next, devices are
enumerated asynchronously. If a stable identifier is use
cxl_memdev_get_serial() which returns a value according to the 'Device
Serial Number Extended Capability' in the PCIe 5.0 Base Specification.

The character device node for command submission can be found by default
at /dev/cxl/mem%d, or created with a major / minor returned from
cxl_memdev_get_{major,minor}().

The 'pmem_size' and 'ram_size' attributes return the current
provisioning of DPA (Device Physical Address / local capacity) in the
device.

=== MEMDEV: Commands
----
struct cxl_cmd *cxl_cmd_new_raw(struct cxl_memdev *memdev, int opcode);
struct cxl_cmd *cxl_cmd_new_identify(struct cxl_memdev *memdev);
struct cxl_cmd *cxl_cmd_new_get_health_info(struct cxl_memdev *memdev);
struct cxl_cmd *cxl_cmd_new_read_label(struct cxl_memdev *memdev,
					unsigned int offset, unsigned int length);
struct cxl_cmd *cxl_cmd_new_write_label(struct cxl_memdev *memdev, void *buf,
					unsigned int offset, unsigned int length);
int cxl_memdev_zero_label(struct cxl_memdev *memdev, size_t length,
			  size_t offset);
int cxl_memdev_read_label(struct cxl_memdev *memdev, void *buf, size_t length,
			  size_t offset);
int cxl_memdev_write_label(struct cxl_memdev *memdev, void *buf, size_t length,
			   size_t offset);

----

A 'cxl_cmd' is a reference counted object which is used to perform 'Mailbox'
commands as described in the CXL Specification. A 'cxl_cmd' object is tied to a
'cxl_memdev'. Associated library interfaces have the prefix 'cxl_cmd_'. Within
this sub-class of interfaces, there are:

 * 'cxl_cmd_new_*()' interfaces that allocate a new cxl_cmd object for a given
   command type targeted at a given memdev. As part of the command
   instantiation process the library validates that the command is
   supported by the memory device, otherwise it returns NULL to indicate
   'no support'. The libcxl command id is translated by the kernel into
   a CXL standard opcode. See the potential command ids in
   /usr/include/linux/cxl_mem.h.

 * 'cxl_cmd_submit' which submits the command via ioctl()

 * 'cxl_cmd_<name>_get_<field>' interfaces that get specific fields out of the
   command response

 * 'cxl_cmd_get_*' interfaces to get general command related information.

cxl_cmd_new_raw() supports so called 'RAW' commands where the command id
is 'RAW' and it carries an unmodified CXL memory device command payload
associated with the 'opcode' argument. Given the kernel does minimal
input validation on these commands typically raw commands are not
supported by the kernel outside debug build scenarios. libcxl is limited
to supporting commands that appear in the CXL standard / public
specifications.

cxl_memdev{read,write,zero}_label() are helpers for marshaling multiple
label access commands over an arbitrary extent of the device's label
area.

BUSES
-----
The CXL Memory space is CPU and Device coherent. The address ranges that
support coherent access are described by platform firmware and
communicated to the operating system via a CXL root object 'struct
cxl_bus'.

=== BUS: Enumeration
----
struct cxl_bus *cxl_bus_get_first(struct cxl_ctx *ctx);
struct cxl_bus *cxl_bus_get_next(struct cxl_bus *bus);
struct cxl_ctx *cxl_bus_get_ctx(struct cxl_bus *bus);
struct cxl_bus *cxl_memdev_get_bus(struct cxl_memdev *memdev);
struct cxl_bus *cxl_endpoint_get_bus(struct cxl_endpoint *endpoint);

#define cxl_bus_foreach(ctx, bus)                                           \
       for (bus = cxl_bus_get_first(ctx); bus != NULL;                      \
            bus = cxl_bus_get_next(bus))
----
When a memdev is active it has established a CXL port hierarchy between
itself and the root of its associated CXL topology. The
cxl_{memdev,endpoint}_get_bus() helpers walk that topology to retrieve
the associated bus object.

=== BUS: Attributes
----
const char *cxl_bus_get_provider(struct cxl_bus *bus);
const char *cxl_bus_get_devname(struct cxl_bus *bus);
int cxl_bus_get_id(struct cxl_bus *bus);
----

The provider name of a bus is a persistent name that is independent of
discovery order. The possible provider names are 'ACPI.CXL' and
'cxl_test'. The devname and id attributes, like other objects, are just
the kernel device names that are subject to change based on discovery
order.

PORTS
-----
CXL ports track the PCIe hierarchy between a platform firmware CXL root
object, through CXL / PCIe Host Bridges, CXL / PCIe Root Ports, and CXL
/ PCIe Switch Ports.

=== PORT: Enumeration
----
struct cxl_port *cxl_bus_get_port(struct cxl_bus *bus);
struct cxl_port *cxl_port_get_first(struct cxl_port *parent);
struct cxl_port *cxl_port_get_next(struct cxl_port *port);
struct cxl_port *cxl_port_get_parent(struct cxl_port *port);
struct cxl_bus *cxl_port_get_bus(struct cxl_port *port);
struct cxl_ctx *cxl_port_get_ctx(struct cxl_port *port);
const char *cxl_port_get_host(struct cxl_port *port);

#define cxl_port_foreach(parent, port)                                      \
       for (port = cxl_port_get_first(parent); port != NULL;                \
            port = cxl_port_get_next(port))
----
A bus object encapsulates a CXL port object. Use cxl_bus_get_port() to
use generic port APIs on root objects.

Ports are hierarchical. All but the a root object have another CXL port
as a parent object retrievable via cxl_port_get_parent().

The root port of a hiearchy can be retrieved via any port instance in
that hierarchy via cxl_port_get_bus().

The host of a port is the corresponding device name of the PCIe Root
Port, or Switch Upstream Port with CXL capabilities.

=== PORT: Attributes
----
const char *cxl_port_get_devname(struct cxl_port *port);
int cxl_port_get_id(struct cxl_port *port);
int cxl_port_is_enabled(struct cxl_port *port);
bool cxl_port_is_root(struct cxl_port *port);
bool cxl_port_is_switch(struct cxl_port *port);
bool cxl_port_is_endpoint(struct cxl_port *port);
bool cxl_port_hosts_memdev(struct cxl_port *port, struct cxl_memdev *memdev);
----
The port type is communicated via cxl_port_is_<type>(). An 'enabled' port
is one that has succeeded in discovering the CXL component registers in
the host device and has enumerated its downstream ports. In order for a
memdev to be enabled for CXL memory operation all CXL ports in its
ancestry must also be enabled including a root port, an arbitrary number
of intervening switch ports, and a terminal endpoint port.

cxl_port_hosts_memdev() returns true if the port's host appears in the
memdev host's device topology ancestry.

ENDPOINTS
---------
CXL endpoint objects encapsulate the set of host-managed device-memory
(HDM) decoders in a physical memory device. The endpoint is the last hop
in a decoder chain that translate SPA to DPA (system-physical-address to
device-local-physical-address).

=== ENDPOINT: Enumeration
----
struct cxl_endpoint *cxl_endpoint_get_first(struct cxl_port *parent);
struct cxl_endpoint *cxl_endpoint_get_next(struct cxl_endpoint *endpoint);
struct cxl_ctx *cxl_endpoint_get_ctx(struct cxl_endpoint *endpoint);
struct cxl_port *cxl_endpoint_get_parent(struct cxl_endpoint *endpoint);
struct cxl_port *cxl_endpoint_get_port(struct cxl_endpoint *endpoint);
const char *cxl_endpoint_get_host(struct cxl_endpoint *endpoint);
struct cxl_endpoint *cxl_memdev_get_endpoint(struct cxl_memdev *memdev);

#define cxl_endpoint_foreach(port, endpoint)                                 \
       for (endpoint = cxl_endpoint_get_first(port); endpoint != NULL;       \
            endpoint = cxl_endpoint_get_next(endpoint))
----

=== ENDPOINT: Attributes
----
const char *cxl_endpoint_get_devname(struct cxl_endpoint *endpoint);
int cxl_endpoint_get_id(struct cxl_endpoint *endpoint);
int cxl_endpoint_is_enabled(struct cxl_endpoint *endpoint);
----

include::../../copyright.txt[]

SEE ALSO
--------
linklibcxl:cxl[1]
